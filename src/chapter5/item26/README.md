# ITEM 26 로 타입은 사용하지 말라

--------------------------------------------
### 제네릭 타입

* 제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입이라 부른다
  * 제네릭 클래스, 제네릭 인터페이스 : 클래스와 인터페이스 선언에 타입 매개변수가 사용된것
```` java
 List<String>은 원소 타입이 String인 리스트를 뜻하는 매개변수화 타입이다
````
* 각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다
  * 먼저 클래스 이름이 나오고 꺾쇠괄호 안에 실제 타입 매개변수들을 나열한다
  * String이 정규타입 매개변수 E에 해당하는 실제 타입 매개변수다


* 제네릭을 사용하면 컴파일러가 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다

### 로타입

* 제네릭 타입을 하나 정의하면 그에 딸린 로타입도 함께 정의된다


* 로타입 : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않는 경우
```` java
 List<E>의 로타입은 List
````
* 로타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작한다


* 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책이다


* 로타입 사용시 컴파일 단계에서 오류가 발생하지 않아 이상적으로 컴파일 단계에서 오류를 발견하는게 불가능하다
  * 런타임 단계에서 오류가 발생한것을 알게 된다
  * 때문에 런타임에 문제가 생긴 코드와 실제 원인 제공 코드가 물리적으로 굉장히 떨어져 있을 가능성이 높다
  * 로타입을 사용하면 제네릭의 장점인 안정성과 표현력을 모두 잃게 된다


* 로타입은 언어 차원에서 막아놓지는 않았지만 절대 사용하면 안된다


* 로타입을 언어 차원에서 막지 않은 이유는 제네릭이 생기기 전 작성된 코드와의 호환성 때문이다
```` java
List 같은 로타입 대신 list<Object> 를 사용하자
````
* 위와 같이 사용하는것은 객체를 허용하는 매개변수화 타입은 모든 타입을 허용한다고 컴파일러에게 알려준 것이기 때문에 괜찮다
```` java
List<Object>같은 매개변수화 타입이 아닌 List 같이 로타입을 사용하면 타입 안정성을 잃게된다

Collection<?>에는 null 외에는 어떤 왼소도 넣을 수 없다
````
### 로타입을 사용해도 되는 경우

* class 리터럴에는 로 타입을 써야 한다

* 자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 해놨다(배열과 기본타입은 허용)

```` java
List.class , String[].class , int.class 가능

List<String>.class , List<?>.class 불가능
````
* instanceof 연산자
  * 런타입에는 제네릭 타입의 정보가 지워져서 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용이 불가능하다
  * 로타입이든 비한정적 와일드카드 타입이든 instanceof 연산자는 똑같이 동작한다
  * 같은 동작을 하기 때문에 코드를 더럽히지 않고 로타입을 쓰는게 낫다

#### 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하지 말자
#### 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다


